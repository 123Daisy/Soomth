import numpy as np
import math
from scipy import integrate
from sympy import *
import matplotlib.pyplot as plt

class Soomth():
    def __init__(self,vs,ve,vmax,amax,jerk,distance):
        self.vs=vs
        self.ve=ve
        self.vmax=vmax
        self.amax=amax
        self.jerk=jerk
        self.distance=distance
        self.te=0
        self.ts=0
        self.tmax=0


    
    def cal_timeOfv(self,a,b,tmax,x):
        t=symbols('t')
        f=a*t**3+b*t**2-x
        new_te = solve(f)
        k=0
        for i in new_te:
            if(i>0):
                temp=round(i,3)
                if(temp<2*tmax):
                    k=temp
        return k

    def changeve(self,a,b,te,smin):
        lr=0.01                 #步长
        v=0.01
        for t in range(100):
            self.ve=self.ve-v
            smin=(smin-lr*self.ve)
            if(np.abs(self.distance-smin)<0.01):
                break
            else:
                self.te=self.te-lr                      #新的te怎么保存下来
                if(self.ve==self.vs):
                    break
        return True
    
    def calsmin(self,ts,te,a,b):
    #integrate(函数，（变量，下限， 上限）)
        t=symbols('t')
        smin=integrate(a*np.power(t,3)+b*np.power(t,3),(t,ts,te))
        return smin

    def step1(self,ts,te,a,b,tmax):
        smin=self.calsmin(ts,te,a,b)
        if(self.distance>smin):
            return True
        else:
            return False

                     
    def step2(self,a,b,c,d):
        sa=self.calsmin(self.ts,2*tmax,a,b)    #vs加速到最大速度需要的距离
        sd=self.calsmin(self.te,2*tmax,a,b)
        if( self.distance>(sa-sd)):
            return sa,sd
        else:
            self.step3(a,b)
     
    def step3(self,a,b):   #调整最大速度/末速度,让整个同样使用梯度下降的方法, vmax,以及tmax
        #调整最大速度,vs加速到最大速度的时间也改变了，时间也需要记录下来
        t=0.01
        self.tmax=self.tmax-t
        self.vmax=a*np.power(self.tmax,3)+b*np.power(self.tmax,2)
        self.step2()
        
#     def step4(self,ts,tmax,t):
#         time=[]
#         time[0]=
#         time[1]=
#         time[2]=
#         return time

    def calParameter1(self,t1):  #(vs<ve)
        a= (self.vmax-2*self.amax)/(np.power(t1,3))
        b= (self.amax/(2*t1)) - (1.5*self.vmax)/np.power(t1,2)-(3*self.amax/np.power(t1,2))
        return a,b
    
    def calParameter2(self,t3):
        a= self.amax/np.power(t3,2)-3*self.vmax/np.power(t3,3)
        b= -2*self.amax/t3+self.vmax/(2*np.power(t3,2))
        return a,b
    
    def caltime(self):
        time=[]
        
#         x=np.linspace(0,2*tmax,1000)    #画出v(t)曲线
#         y=[ a*np.power(t,3)+b*np.power(t,2) for t in x]
#         plt.plot(x,y,'r.')
#         print(a,b)
        if(self.vs<=self.ve):
            if(self.vs==self.ve and self.ve==self.vmax):
                time[0]=time[1]=time[2]=self,discrete/self.vmax
                return time
            else:
                a,b=self.calParameter1(t) #计算v(t),a(t)的系数
                a=round(a,3)
                b=round(b,3)
                c,d=self.calParameter2(t)
                self.ts=self.cal_timeOfv(a,b,self.tmax,self.vs)                            #调用
                self.te=self.cal_timeOfv(a,b,self.tmax,self.ve)
                if( self.step1( self.ts,self.te,a,b,self.tmax ) ):
                    sa,sd=self.step2(a,b,c,d)
#                     time=self.step4(sa,sd)
                    return time
                else:
                    self.changeve(a,b,smin)  #new_te需要修改 梯度下降法
                    time[0]=self.te-self.ts
                    return time
#         else:   #减速运动
            

if __name__=='__main__':
    model=Soomth(20,30,300,2000,49280,300)
    time=model.caltime()
