import numpy as np
import math
from scipy import integrate
from sympy import *
import matplotlib.pyplot as plt

class Soomth():
    def __init__(self,vs,ve,vmax,amax,jerk,distance):
        self.vs=vs
        self.ve=ve
        self.vmax=vmax
        self.amax=amax
        self.jerk=jerk
        self.distance=distance
        self.te=0
        self.ts=0
        self.tmax=0
        

    def calParameter(self,tmax):
        a= - (self.vmax/ ( 4 * np.power(tmax,3) ) )
        b= 3/4*( self.vmax /np.power(tmax,2))
        return a,b

    def calsmin(self,ts,te,a,b):
        #integrate(函数，（变量，下限， 上限）)
        t=symbols('t')
        smin=integrate(a*np.power(t,3)+b*np.power(t,3),(t,ts,te))
        return smin
    
    def cal_timeOfv(self,a,b,tmax,x):
        t=symbols('t')
        f=a*t**3+b*t**2-x
        new_te = solve(f)
        k=0
        for i in new_te:
            temp=round(i,3)
            if(temp>0):
                if(temp<2*tmax):
                    k=temp
        return k

    def changeve(self,a,b,te,smin):
        lr=0.01                 #步长
        v=0.01
        for t in range(100):
            self.ve=self.ve-v
            smin=(smin-lr*self.ve)
            if(np.abs(self.distance-smin)<0.01):
                break
            else:
                self.te=self.te-t

                
                *lr                                #新的te怎么保存下来
                if(self.ve==self.vs):
                    break
        return True

    def step1(self,ts,te,a,b,tmax):
        smin=self.calsmin(ts,te,a,b)
        if(np.abs(self.distance-smin)<0.01 ):
            return True
        else: 
            return self.changeve(a,b,te,smin)  #new_te需要修改
            #te是新的te下,利用一元三次方程求根通式求得 方法一
                     
    def step2(self,ts,te,tmax,a,b):
        sa=self.calsmin(ts,2*tmax,a,b)    #vs加速到最大速度需要的距离
        sd=self.calsmin(te,2*tmax.a,b)
        if( self.distance>(sa-sd)):
            return sa,sd
        else:
            self.step3()
     
    def step3(self,ts,te,a,b,tmax):   #调整最大速度/末速度,让整个同样使用梯度下降的方法, vmax,以及tmax
        self.step2()
        
#     def step4(self,ts,tmax,t):
#         time=[]
#         time[0]=
#         time[1]=
#         time[2]=
#         return time
    
    def caltime(self):
        time=[]
        self.tmax=self.jerk/self.amax             
        a,b=self.calParameter(tmax) #计算v(t),a(t)的系数
        a=round(a,3)
        b=round(b,3)
#         x=np.linspace(0,2*tmax,1000)    #画出v(t)曲线
#         y=[ a*np.power(t,3)+b*np.power(t,2) for t in x]
#         plt.plot(x,y,'r.')
#         print(a,b)
        if(self.vs<=self.ve):
            if(self.vs==self.ve and self.ve==self.vmax):
                time[0]=time[1]=time[2]=self,discrete/self.vmax
                return time
            else:
                self.ts=self.cal_timeOfv(a,b,tmax,self.vs)                            #调用
                self.te=self.cal_timeOfv(a,b,tmax,self.vs)
                if(self.step1(self.ts,self.te,a,b,tmax)):
                    sa,sd=self.step2(self.ts,self.te,tmax,a,b)
                    time=self.step4(sa,sd)
                    return time
#         else:   #减速运动
            

if __name__=='__main__':
    model=Soomth(20,30,300,2000,49280,300)
    time=model.caltime()
